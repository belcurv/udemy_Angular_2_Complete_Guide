## Udemy - Angular 2 The Complete Guide

### Section 1: Getting Started

**Install Angular CLI via NPM:**

`sudo npm install -g @angular/cli`

**Creating a new project**

`ng new {name of your new project}`

> Holy shit - it takes _forever_ to generate a new app.

Once the new app is finshed installing, start the server to make sure it all worked:

`ng serve`

That bundles the app using Webpack and starts a local server running on port 4200 (localhost:4200). This takes a while too.

**Editing our new project**

We can ignore most of the files/folders generated by `angular-cli`. We will work primarily in the `/src` folder.

`index.html` serves our SPA. We don't need to edit it at all - we'll work in `/src/app`.

**app.component.ts**
We build our Angular applications out of components.  The `app.component` is the one component we define that loads on initialpage load.

**ngModel is ... different**


`app.component.ts` looks like this:

```javascript
    import { Component } from '@angular/core';

    @Component({
        selector: 'app-root',
        templateUrl: './app.component.html',
        styleUrls: ['./app.component.css']
    })
    export class AppComponent {
        name = '';
    }
```

See the `export class Appcomponent` bit? the `name` property (variable?) in there is bound to the view (like $scope does in Angular 1).  Then, in `app.component.html` we do:

```
    <input type="text" [(ngModel)]="name">
    <p>{{ name }}</p>
```

The new view syntax for ngModel = `[(ngModel)]="bound-variable"`

**What hasn't changed?**

1.  Templates, DataBinding and Directives still exist.
2.  Services and Dependency still exist.
3.  Routing is still a thing.
4.  Pipes (for transforming template output) still exist

**What's new?**

1.  Observables

**Decorators**

Decorators make Angular 2 components _components_. Without them, they're nothing.

All components need exactly 1 template. Template is controlled by the TS code in our class.

```javascript
@Component({
    selector: 'app-root',  // our new html element
    templateUrl: './app-root.component.html',  // our template file 
    styleUrls: []          // this component's css
})
```

**TypeScript**

More features than vanilla JS (e.g. Types, Classes, Interfaces, ...).

**Boostrapping**

`/src/main.ts` is run first and bootstraps our main module, AppModule: 

```javascript
    import { enableProdMode } from '@angular/core';
    import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';

    import { AppModule } from './app/app.module';
    import { environment } from './environments/environment';

    if (environment.production) {
      enableProdMode();
    }

    platformBrowserDynamic().bootstrapModule(AppModule);
```

In the last line, the `bootstrapModule()` method is passed one argument: the `AppModule` imported in the 4th line from `./app/app.module.ts`.

Looking at `app.module.ts`, notice the `bootstrap: [AppComponent]` array in the decorator - this is where the circle closes: we reference our appComponent (`./app/app.component.ts`).

So it all works like this:

1.  `main.ts` loads first bootstrapping our main application, passing our `app.module.ts` module as an argument
2.  in `app.module.ts` we tell Angular to bootstrap our `appComponent` component.
3.  Angular loads `appComponent` which references a `app-root` selector, and 
4.  now Angular can handle `app-root` in `index.html`, inserting `appComponent` in place of the directive.

####Components

Key feature. We'll compose the whole application from components we'll create.

We start with our appComponent - the root component. On one hand it's a normal Angular component; on the other hand it's special because it's our root component.  We'll later add additional components to this one. Their selectors will not be added to our `index.html` file; instead they'll be added to `app/app.component.html`.

**A component is a TypsScript class**. Angular is able to instantiate it - to create objects based on this "blueprint".

When making our own components, we'll begin by naming and exporting it (because we need to _import_ it elsewhere):

```javascript
export class ServerComponent {

}
```

That's a normal TypeScript class, named "ServerComponent". But it doesn't do anything - it needs more information: a **decorator** tells Angular this is a component. We'll use the Component decorator, which we need to import before we can use:

```javascript
import { Component } from '@angular/core'    // import Component from Angular core

@Component({                                 // init Component, which takes a config object
    selector: 'app-server',                  // html element
    templateUrl: './server.component.html'   // template
})
export class ServerComponent {

}
```

Before we can use this component, we need to update our `app.module.ts`. Angular uses components to build we pages, and uses modules to bundle pieces (components, etc) into packages. What does `appModule` do? It's a collection of our app's features. We need to register our new `app-server` component in `appModule` before we can use it. Add an `import` statement and include the component's name in the `declarations` property of NgModule's config object:

```javascript
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { HttpModule } from '@angular/http';

import { AppComponent } from './app.component';
import { ServerComponent } from './server/server.component';

@NgModule({
    declarations: [
        AppComponent,
        ServerComponent
    ],
    imports: [
        BrowserModule,
        FormsModule,
        HttpModule
    ],
    providers: [],
    bootstrap: [AppComponent]
})
export class AppModule { }
```

We can also create components with the CLI. Say we wanted our `app-server` component nested inside a `servers` component.

```
ng generate component servers
```

(shorthand for the same)

```
ng g c servers
```